(require-extension test)

;;
;; 1.2 Procedures and the processes they generate
;;

; The previous section introduced elements of programming but not the common
; tactics and strategies to effectively develop programs.
;
; Emphasis of the importance of being able to "visualize" the effects of
; procedures before writing them.
;
; A procedure is a pattern for the "local evolution" of a computational process.
; It specifies how each stage of the process is built upon the previous stage.
; This section describes some common "shapes" for processes generated by simple
; procedures.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;
;; 1.2.1 Linear recursion and iteration
;;

; A linear recursive implementation of the factorial function:

(include "factorial-recursive.scm")

(test 1 (factorial 1))
(test 2 (factorial 2))
(test 6 (factorial 3))

; The recursive approach/process builds up a chain of "deferred operations",
; which in this case is a chain of multiplications. In the case of the
; factorial, the amount of information to keep track of grows linearly with
; n, hence a "linear recursive process".

(include "factorial-iterative.scm")

(test 1 (factorial 1))
(test 2 (factorial 2))
(test 6 (factorial 3))

; The iterative approach/process keeps track of a fixed number of state
; variables, together with a fixed rule that describes how the state variables
; should be updated as the process moves from state to state and an (optional)
; end test that specifies conditions under which the process should terminate.
; In our factorial function, the number of steps required grows linearly with n,
; hence it is a "linear iterative process".
;
; The state of iterative processes is completely contained in the state variables,
; while hidden information is maintained by the interpreter for recursive
; processes.
;
; Distinction between "recursive processes" and "recursive procedures":
; A recursive procedure is a syntactic notion, and it doesn't necessarily
; result in a recursive process. The distinction lies in whether or not the
; state of the procedure are completely specified by its variables, or by
; deferred action stored in the interpreter.
; Footnote: any iterative process can be realized in hardware as a machine
; that has a fixed set of registers and no auxiliary memory. A recursive
; process, in contrast, requires a "stack" in addition to the fixed set of
; registers.
;
; Scheme is able to execute recursive procedures that describe iterative
; processes in constant space, due to the "tail-recursive" property of the
; interpreter.

;
; Exercise 1.9: Use the substitution model to illustrate the process generated
;               by the following procedures, and determine whether they are
;               iterative or recursive.
;
(define (inc x)
  (+ x 1))

(define (dec x)
  (- x 1))

(define (plus a b)
  (if (= a 0) b (inc (plus (dec a) b))))

(test 3 (plus 1 2))

; in the version above, each (plus) call depends on a previous call,
; which cannot be known until a has been decremented to zero, matching the
; definition of "a series of deferred operations" which describes a recursive
; process.


(define (plus a b)
  (if (= a 0) b (plus (dec a) (inc b))))

(test 3 (plus 1 2))

; in the version above, although the (plus) call doesn't return until
; a has been decremented to zero, it does not depend on any previous
; calls to itself, meaning there are no deferred operations. Thus this
; procedure is iterative and not recursive.

;
; Exercise 10: the following procedure implements Ackermann's function:
;
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

; What are the values of the following expressions?
;
; (A 1 10)
;
; Let's look at the boundary cases first.
; (A 1 0) => 0
(test 0 (A 1 0))
;
; (A 1 1) => 2
(test 2 (A 1 1))
;
; (A 1 2) => (A 0 (A 1 1))
;         => (A 0 2)
;         => (* 2 2)
;         => 4
(test 4 (A 1 2))
;
; (A 1 3) => (A 0 (A 1 2))
;         => (A 0 (A 0 (A 1 1)))
;         => (A 0 (A 0 2))
;         => (A 0 (* 2 2))
;         => (* 2 (* 2 2))
;         => 8
(test 8 (A 1 3))
;
; By induction, (A 1 n) => 2**n
; Thus (A 1 10) => 2**10 => 1024
(test 1024 (A 1 10))

; (A 2 4)
;
; Boundary cases:
; (A 2 0) => 0
(test 0 (A 2 0))
;
; (A 2 1) => 2
(test 2 (A 2 1))
;
; (A 2 2) => (A 1 (A 2 1))
;         => (A 1 2)
;         => 2**2
;         => 4
(test 4 (A 2 2))
;
; (A 2 3) => (A 1 (A 2 2))
;         => (A 1 4)
;         => 2**4
;         => 16
(test 16 (A 2 3))
;
; By induction, (A 2 n) => (A 1 (A 2 (- n 1)))
; (A 2 4) => (A 1 (A 2 3))
;         => (A 1 16)
;         => 2**16
;         => 65536
;
(test 65536 (A 2 4))

; (A 3 3)
; 
; Boundary cases:
; (A 3 0) => 0
; (A 3 1) => 2
; (A 3 2) => (A 2 (A 3 1))
;         => (A 2 2)
;         => (A 1 (A 2 1))
;         => (A 1 2)
;         => 4
; (A 3 3) => (A 2 (A 3 2))
;         => (A 2 4)
;         => 65536
(test 65536 (A 3 3))

;;
;; 1.2.2 Tree recursion
;;

; Recursive implementation of Fibonacci numbers:
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))

; The recursive procedure for calculating Fibonacci numbers is shown to be
; tree recursive, hence duplicating a lot of work: the number of times it will
; compute (fib 1) and (fib 0) is precisely Fib(n+1), where the value of Fib(n)
; grows exponentially with n. More precisely, Fib(n) is the closest integer
; to phi^n / sqrt(5), where phi = (1 + sqrt(5))/2 ~ 1.6180, the Golden Ratio,
; which satisfies phi^2 = phi + 1.
;
; In general, the number of steps required by a tree-recursive process will
; be proportional to the number of nodes in the tree, while the space required
; will be proportional to the maximum depth of the tree.
;
; Iterative implementation of fib:
(define (fib n)
  (fib-iter 1 0 n))
(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
;
; The complexity of the iterative implementation is linear in n, thus much
; efficient, yet tree recursive processes aren't necessarily useless; they
; are a natural and powerful tool for dealing with hierarchical data
; structures.

; Example: counting change
; The nuber of ways to change amount `a` using `n` kinds of coins equals:
;  - the number of ways to change amount a using all but the first kind of coin, plus
;  - the number of ways to change amount `a - d` using all `n` kinds of coins, where `d`
;    is the denomination of the first kind of coin
;
; We can recursively reduce the problem of changing a given amount to the problem of
; changing smaller amounts using fewer kinds of coins.
;
; The algorithm:
; If `a` is exactly 0, we should count that as 1 way to make change
; If `a` is less than 0, we should count that as 0 ways to make change
; If `n` is 0, we should count that as 0 ways to make change

(define (count-change amount) (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

(test 1 (cc 0 5))
(test 292 (count-change 100))

; Being a tree-recursive process, this procedure also makes redundant calculations,
; hence it isn't as efficient as an iterative implementation. It isn't obvious how to
; design a better algorithm for computing the result, and the author has left this
; as a challenge.
;
; Some have suggested that we can get the best of both worlds by designing a smart
; compiler than automatically converts a recursive process into an iterative process.
;
; Footnote: Tabulation or "memoization" can be used to improve the performance, which
; is relatively easy to implement.

;
; Exercise 1.11: A function `f` is defined by the rule that
;
;                f(n) = n if n < 3,
;                f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n >= 3
;
;                write a procedure that computes `f` by means of a recursive process.
;                write a procedure that computes `f` by means of an iterative process
; f(0) => 0
; f(1) => 1
; f(2) => 2
; f(3) => f(2) + 2f(1) + 3f(0) => 4
; f(4) => f(3) + 2f(2) + 3f(1) => 11

; Recursive implementation:
(define (f n)
        (if (< n 3)
            n
            (+ (f (- n 1))
               (* 2 (f (- n 2)))
               (* 3 (f (- n 3))))))
(test 0 (f 0))
(test 1 (f 1))
(test 2 (f 2))
(test 4 (f 3))
(test 11 (f 4))

; Iterative implementation: this is very similar to (fib) in that it takes
; three previous terms instead of two to derive f(n)
; state variable: previous 3 terms and counter
(define (f n)
  (define (f-iter a b c count)
    (if (= count 0)
        c
        (f-iter (+ a (* 2 b) (* 3 c)) a b (- count 1))))
  (if (< n 3)
      n
      (f-iter 2 1 0 n)))

(test 0 (f 0))
(test 1 (f 1))
(test 2 (f 2))
(test 4 (f 3))
(test 11 (f 4))
