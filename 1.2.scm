(require-extension test)

;;
;; 1.2 Procedures and the processes they generate
;;

; The previous section introduced elements of programming but not the common
; tactics and strategies to effectively develop programs.
;
; Emphasis of the importance of being able to "visualize" the effects of
; procedures before writing them.
;
; A procedure is a pattern for the "local evolution" of a computational process.
; It specifies how each stage of the process is built upon the previous stage.
; This section describes some common "shapes" for processes generated by simple
; procedures.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;
;; 1.2.1 Linear recursion and iteration
;;

; A linear recursive implementation of the factorial function:

(include "factorial-recursive.scm")

(test 1 (factorial 1))
(test 2 (factorial 2))
(test 6 (factorial 3))

; The recursive approach/process builds up a chain of "deferred operations",
; which in this case is a chain of multiplications. In the case of the
; factorial, the amount of information to keep track of grows linearly with
; n, hence a "linear recursive process".

(include "factorial-iterative.scm")

(test 1 (factorial 1))
(test 2 (factorial 2))
(test 6 (factorial 3))

; The iterative approach/process keeps track of a fixed number of state
; variables, together with a fixed rule that describes how the state variables
; should be updated as the process moves from state to state and an (optional)
; end test that specifies conditions under which the process should terminate.
; In our factorial function, the number of steps required grows linearly with n,
; hence it is a "linear iterative process".
;
; The state of iterative processes is completely contained in the state variables,
; while hidden information is maintained by the interpreter for recursive
; processes.
;
; Distinction between "recursive processes" and "recursive procedures":
; A recursive procedure is a syntactic notion, and it doesn't necessarily
; result in a recursive process. The distinction lies in whether or not the
; state of the procedure are completely specified by its variables, or by
; deferred action stored in the interpreter.
; Footnote: any iterative process can be realized in hardware as a machine
; that has a fixed set of registers and no auxiliary memory. A recursive
; process, in contrast, requires a "stack" in addition to the fixed set of
; registers.
;
; Scheme is able to execute recursive procedures that describe iterative
; processes in constant space, due to the "tail-recursive" property of the
; interpreter.

;
; Exercise 1.9: Use the substitution model to illustrate the process generated
;               by the following procedures, and determine whether they are
;               iterative or recursive.
;
(define (inc x)
  (+ x 1))

(define (dec x)
  (- x 1))

(define (plus a b)
  (if (= a 0) b (inc (plus (dec a) b))))

(test 3 (plus 1 2))

; in the version above, each (plus) call depends on a previous call,
; which cannot be known until a has been decremented to zero, matching the
; definition of "a series of deferred operations" which describes a recursive
; process.


(define (plus a b)
  (if (= a 0) b (plus (dec a) (inc b))))

(test 3 (plus 1 2))

; in the version above, although the (plus) call doesn't return until
; a has been decremented to zero, it does not depend on any previous
; calls to itself, meaning there are no deferred operations. Thus this
; procedure is iterative and not recursive.

;
; Exercise 10: the following procedure implements Ackermann's function:
;
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

; What are the values of the following expressions?
;
; (A 1 10)
;
; Let's look at the boundary cases first.
; (A 1 0) => 0
(test 0 (A 1 0))
;
; (A 1 1) => 2
(test 2 (A 1 1))
;
; (A 1 2) => (A 0 (A 1 1))
;         => (A 0 2)
;         => (* 2 2)
;         => 4
(test 4 (A 1 2))
;
; (A 1 3) => (A 0 (A 1 2))
;         => (A 0 (A 0 (A 1 1)))
;         => (A 0 (A 0 2))
;         => (A 0 (* 2 2))
;         => (* 2 (* 2 2))
;         => 8
(test 8 (A 1 3))
;
; By induction, (A 1 n) => 2**n
; Thus (A 1 10) => 2**10 => 1024
(test 1024 (A 1 10))

; (A 2 4)
;
; Boundary cases:
; (A 2 0) => 0
(test 0 (A 2 0))
;
; (A 2 1) => 2
(test 2 (A 2 1))
;
; (A 2 2) => (A 1 (A 2 1))
;         => (A 1 2)
;         => 2**2
;         => 4
(test 4 (A 2 2))
;
; (A 2 3) => (A 1 (A 2 2))
;         => (A 1 4)
;         => 2**4
;         => 16
(test 16 (A 2 3))
;
; By induction, (A 2 n) => (A 1 (A 2 (- n 1)))
; (A 2 4) => (A 1 (A 2 3))
;         => (A 1 16)
;         => 2**16
;         => 65536
;
(test 65536 (A 2 4))

; (A 3 3)
; 
; Boundary cases:
; (A 3 0) => 0
; (A 3 1) => 2
; (A 3 2) => (A 2 (A 3 1))
;         => (A 2 2)
;         => (A 1 (A 2 1))
;         => (A 1 2)
;         => 4
; (A 3 3) => (A 2 (A 3 2))
;         => (A 2 4)
;         => 65536
(test 65536 (A 3 3))

