(require-extension test)

;;
;; 1.2 Procedures and the processes they generate
;;

; The previous section introduced elements of programming but not the common
; tactics and strategies to effectively develop programs.
;
; Emphasis of the importance of being able to "visualize" the effects of
; procedures before writing them.
;
; A procedure is a pattern for the "local evolution" of a computational process.
; It specifies how each stage of the process is built upon the previous stage.
; This section describes some common "shapes" for processes generated by simple
; procedures.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;
;; 1.2.1 Linear recursion and iteration
;;

; A linear recursive implementation of the factorial function:

(include "factorial-recursive.scm")

(test 1 (factorial 1))
(test 2 (factorial 2))
(test 6 (factorial 3))

; The recursive approach/process builds up a chain of "deferred operations",
; which in this case is a chain of multiplications. In the case of the
; factorial, the amount of information to keep track of grows linearly with
; n, hence a "linear recursive process".

(include "factorial-iterative.scm")

(test 1 (factorial 1))
(test 2 (factorial 2))
(test 6 (factorial 3))

; The iterative approach/process keeps track of a fixed number of state
; variables, together with a fixed rule that describes how the state variables
; should be updated as the process moves from state to state and an (optional)
; end test that specifies conditions under which the process should terminate.
; In our factorial function, the number of steps required grows linearly with n,
; hence it is a "linear iterative process".
;
; The state of iterative processes is completely contained in the state variables,
; while hidden information is maintained by the interpreter for recursive
; processes.
;
; Distinction between "recursive processes" and "recursive procedures":
; A recursive procedure is a syntactic notion, and it doesn't necessarily
; result in a recursive process. The distinction lies in whether or not the
; state of the procedure are completely specified by its variables, or by
; deferred action stored in the interpreter.
; Footnote: any iterative process can be realized in hardware as a machine
; that has a fixed set of registers and no auxiliary memory. A recursive
; process, in contrast, requires a "stack" in addition to the fixed set of
; registers.
;
; Scheme is able to execute recursive procedures that describe iterative
; processes in constant space, due to the "tail-recursive" property of the
; interpreter.

;
; Exercise 1.9: Use the substitution model to illustrate the process generated
;               by the following procedures, and determine whether they are
;               iterative or recursive.
;
(define (inc x)
  (+ x 1))

(define (dec x)
  (- x 1))

(define (plus a b)
  (if (= a 0) b (inc (plus (dec a) b))))

(test 3 (plus 1 2))

; in the version above, each (plus) call depends on a previous call,
; which cannot be known until a has been decremented to zero, matching the
; definition of "a series of deferred operations" which describes a recursive
; process.


(define (plus a b)
  (if (= a 0) b (plus (dec a) (inc b))))

(test 3 (plus 1 2))

; in the version above, although the (plus) call doesn't return until
; a has been decremented to zero, it does not depend on any previous
; calls to itself, meaning there are no deferred operations. Thus this
; procedure is iterative and not recursive.

;
; Exercise 10: the following procedure implements Ackermann's function:
;
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

; What are the values of the following expressions?
;
; (A 1 10)
;
; Let's look at the boundary cases first.
; (A 1 0) => 0
(test 0 (A 1 0))
;
; (A 1 1) => 2
(test 2 (A 1 1))
;
; (A 1 2) => (A 0 (A 1 1))
;         => (A 0 2)
;         => (* 2 2)
;         => 4
(test 4 (A 1 2))
;
; (A 1 3) => (A 0 (A 1 2))
;         => (A 0 (A 0 (A 1 1)))
;         => (A 0 (A 0 2))
;         => (A 0 (* 2 2))
;         => (* 2 (* 2 2))
;         => 8
(test 8 (A 1 3))
;
; By induction, (A 1 n) => 2**n
; Thus (A 1 10) => 2**10 => 1024
(test 1024 (A 1 10))

; (A 2 4)
;
; Boundary cases:
; (A 2 0) => 0
(test 0 (A 2 0))
;
; (A 2 1) => 2
(test 2 (A 2 1))
;
; (A 2 2) => (A 1 (A 2 1))
;         => (A 1 2)
;         => 2**2
;         => 4
(test 4 (A 2 2))
;
; (A 2 3) => (A 1 (A 2 2))
;         => (A 1 4)
;         => 2**4
;         => 16
(test 16 (A 2 3))
;
; By induction, (A 2 n) => (A 1 (A 2 (- n 1)))
; (A 2 4) => (A 1 (A 2 3))
;         => (A 1 16)
;         => 2**16
;         => 65536
;
(test 65536 (A 2 4))

; (A 3 3)
; 
; Boundary cases:
; (A 3 0) => 0
; (A 3 1) => 2
; (A 3 2) => (A 2 (A 3 1))
;         => (A 2 2)
;         => (A 1 (A 2 1))
;         => (A 1 2)
;         => 4
; (A 3 3) => (A 2 (A 3 2))
;         => (A 2 4)
;         => 65536
(test 65536 (A 3 3))

;;
;; 1.2.2 Tree recursion
;;

; Recursive implementation of Fibonacci numbers:
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))

; The recursive procedure for calculating Fibonacci numbers is shown to be
; tree recursive, hence duplicating a lot of work: the number of times it will
; compute (fib 1) and (fib 0) is precisely Fib(n+1), where the value of Fib(n)
; grows exponentially with n. More precisely, Fib(n) is the closest integer
; to phi^n / sqrt(5), where phi = (1 + sqrt(5))/2 ~ 1.6180, the Golden Ratio,
; which satisfies phi^2 = phi + 1.
;
; In general, the number of steps required by a tree-recursive process will
; be proportional to the number of nodes in the tree, while the space required
; will be proportional to the maximum depth of the tree.
;
; Iterative implementation of fib:
(define (fib n)
  (fib-iter 1 0 n))
(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
;
; The complexity of the iterative implementation is linear in n, thus much
; efficient, yet tree recursive processes aren't necessarily useless; they
; are a natural and powerful tool for dealing with hierarchical data
; structures.

; Example: counting change
; The nuber of ways to change amount `a` using `n` kinds of coins equals:
;  - the number of ways to change amount a using all but the first kind of coin, plus
;  - the number of ways to change amount `a - d` using all `n` kinds of coins, where `d`
;    is the denomination of the first kind of coin
;
; We can recursively reduce the problem of changing a given amount to the problem of
; changing smaller amounts using fewer kinds of coins.
;
; The algorithm:
; If `a` is exactly 0, we should count that as 1 way to make change
; If `a` is less than 0, we should count that as 0 ways to make change
; If `n` is 0, we should count that as 0 ways to make change

(define (count-change amount) (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

(test 1 (cc 0 5))
(test 292 (count-change 100))

; Being a tree-recursive process, this procedure also makes redundant calculations,
; hence it isn't as efficient as an iterative implementation. It isn't obvious how to
; design a better algorithm for computing the result, and the author has left this
; as a challenge.
;
; Some have suggested that we can get the best of both worlds by designing a smart
; compiler than automatically converts a recursive process into an iterative process.
;
; Footnote: Tabulation or "memoization" can be used to improve the performance, which
; is relatively easy to implement.

;
; Exercise 1.11: A function `f` is defined by the rule that
;
;                f(n) = n if n < 3,
;                f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n >= 3
;
;                write a procedure that computes `f` by means of a recursive process.
;                write a procedure that computes `f` by means of an iterative process
; f(0) => 0
; f(1) => 1
; f(2) => 2
; f(3) => f(2) + 2f(1) + 3f(0) => 4
; f(4) => f(3) + 2f(2) + 3f(1) => 11

; Recursive implementation:
(define (f n)
        (if (< n 3)
            n
            (+ (f (- n 1))
               (* 2 (f (- n 2)))
               (* 3 (f (- n 3))))))
(test 0 (f 0))
(test 1 (f 1))
(test 2 (f 2))
(test 4 (f 3))
(test 11 (f 4))

; Iterative implementation: this is very similar to (fib) in that it takes
; three previous terms instead of two to derive f(n)
; state variable: previous 3 terms and counter
(define (f n)
  (define (f-iter a b c count)
    (if (= count 0)
        c
        (f-iter (+ a (* 2 b) (* 3 c)) a b (- count 1))))
  (if (< n 3)
      n
      (f-iter 2 1 0 n)))

(test 0 (f 0))
(test 1 (f 1))
(test 2 (f 2))
(test 4 (f 3))
(test 11 (f 4))

;
; Exercise 1.12: Write a procedure that computes elements of Pascal's triangle
;                by means of a recursive process
;
; My strategy is to write a procedure f(i, j) that takes two arguments: a vertical position
; and a horizontal pozition. Since it is a triangle, for number with position i, j,
; the two numbers above it will have position (i-1, j-1) and (i-1, j). The resulting
; rule:
; f(i, j) = 1 when i==0 or j==0 or i==j
; f(i, j) = f(i-1, j-1) + f(i-1, j) otherwise

(define (pascals-triangle i j)
  (if (or (= i 0) (= j 0) (= i j))
      1
      (+ (pascals-triangle (- i 1) (- j 1))
         (pascals-triangle (- i 1) j))))
(test 1 (pascals-triangle 0 0))
(test 1 (pascals-triangle 1 0))
(test 1 (pascals-triangle 1 1))
(test 1 (pascals-triangle 2 0))
(test 2 (pascals-triangle 2 1))
(test 1 (pascals-triangle 2 2))
(test 1 (pascals-triangle 3 0))
(test 3 (pascals-triangle 3 1))
(test 3 (pascals-triangle 3 2))
(test 1 (pascals-triangle 3 3))

;
; TODO
; Exercise 1.13: Prove that Fib(n) is the closest integer to phi^n/sqrt(5), where
;                phi = (1 + sqrt(5)) / 2
;

;;
;; 1.2.3 Orders of Growth
;;
; Introduces theta-notation: Let n be a parameter that measures the size of the problem,
; and let R(n) be the amount of resources the process requires for a problem of size n.
; We say that R(n) has order of growth Theta(f(n)), written R(n) = Theta(f(n)), if there
; are positive constants k1 and k2 independent of n such that k1f(n) <= R(n) <= k2f(n)
; for any sufficiently large value of n.
;
; For example: with the linear recursive process for calculating factorials, the steps
; required grows as Theta(n), as well as the space required. With the iterative
; factorial, the number of steps grows as Theta(n) while the space required grows as
; Theta(1), i.e. constant.

;
; TODO
; Exercise 1.14: draw the tree illustrating the process generated by the count-change
;                procedure of section 1.2.2 in making change for 11 cents. What are the
;                orders of growth of the space and number of steps used by this process
;                as the amount to be changed increases?
;

;
; TODO
; Exercise 1.15: The following procedures calculate the sine(x) using the following
;                approximations:
;                 # sin(x) ~ x when x is sufficently small
;                 # sin(x) = 3sin(x/3) - 4sin^3(x/3)
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))
;                 a. How many times is the procedure p applied when (sine 12.15) is
;                    evaluated?
;                 b. What is the order of growth in space and number of steps (as a
;                    function of a) used by the process generated by the sine
;                    procedure when (sine a) is evaluated?

;;
;; 1.2.4 Exponentiation
;;

; Taking advantage of squares, we can implement a fast exponentiation procedure
; that is Theta(log(n)) in both number of steps and space.
(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))

(define (even? n)
  (= (remainder n 2) 0))

(test 4 (fast-expt 2 2))
(test 9 (fast-expt 3 2))

;
; Exercise 1.16: design a procedure that evolves an iterative exponentiation
;                process that uses successive squaring and uses a logarithmic
;                number of steps, as does fast-expt.
;
;
(define (fast-expt-iter b n a)
        ; if n == 0, return a
  (cond ((= n 0) a)

        ; if n is even, divide n by 2. when n reaches 2, the result will
        ; be 1 and the next iter will result in a * b
        ((even? n) (fast-expt-iter (square b) (/ n 2) a))    

        ; if n i odd, subract n by 1 and change a to by a * b
        (else (fast-expt-iter b (- n 1) (* a b)))))

(test 4 (fast-expt-iter 2 2 1))
(test 9 (fast-expt-iter 3 2 1))
(test 8 (fast-expt-iter 2 3 1))
(test 16 (fast-expt-iter 2 4 1))
(test 32 (fast-expt-iter 2 5 1))
(test 64 (fast-expt-iter 2 6 1))
(test 128 (fast-expt-iter 2 7 1))
(test 1024 (fast-expt-iter 2 10 1))
(test 10000 (fast-expt-iter 100 2 1))

;
; Exercise 1.7: design a multiplication procedure analogous to fast-expt
;               that uses a logarithmic number of steps
;
(define (fast-mul-iter m n a)
  (cond ((= n 0) a)
        ((even? n) (fast-mul-iter (double m) (halve n) a))
        (else (fast-mul-iter m (- n 1) (+ a m)))))

(define (double x)
  (+ x x))

(define (halve x)
  (/ x 2))

(test (* 2 2) (fast-mul-iter 2 2 0))
(test (* 2 3) (fast-mul-iter 2 3 0))
(test (* 2 4) (fast-mul-iter 2 4 0))
(test (* 12 12) (fast-mul-iter 12 12 0))
(test (* 12345 12345) (fast-mul-iter 12345 12345 0))
